// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM tickets
WHERE id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTicket, id)
	return err
}

const expireTickets = `-- name: ExpireTickets :execresult
DELETE FROM tickets
WHERE id IN (SELECT id FROM tickets as t WHERE t.status != 'pending' AND t.runat <= $1 LIMIT $2)
`

type ExpireTicketsParams struct {
	ExpireBefore pgtype.Timestamptz
	Lim          int32
}

func (q *Queries) ExpireTickets(ctx context.Context, arg ExpireTicketsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, expireTickets, arg.ExpireBefore, arg.Lim)
}

const getTicket = `-- name: GetTicket :one
SELECT 'ticket' as ticket, id, status, runat, nice, type, ctime, mtime, attempts, payload, error_reason
FROM tickets
WHERE tickets.id = $1
`

type GetTicketRow struct {
	Ticket      string
	ID          uuid.UUID
	Status      string
	Runat       pgtype.Timestamptz
	Nice        int16
	Type        string
	Ctime       pgtype.Timestamptz
	Mtime       pgtype.Timestamptz
	Attempts    int32
	Payload     []byte
	ErrorReason []byte
}

func (q *Queries) GetTicket(ctx context.Context, id uuid.UUID) (GetTicketRow, error) {
	row := q.db.QueryRow(ctx, getTicket, id)
	var i GetTicketRow
	err := row.Scan(
		&i.Ticket,
		&i.ID,
		&i.Status,
		&i.Runat,
		&i.Nice,
		&i.Type,
		&i.Ctime,
		&i.Mtime,
		&i.Attempts,
		&i.Payload,
		&i.ErrorReason,
	)
	return i, err
}

const pollTickets = `-- name: PollTickets :many
WITH rescheduled_tickets AS (
    UPDATE tickets as t
    SET
        attempts = attempts + 1,
        runat = $1::Timestamptz + (GREATEST($2, 0) + LEAST($3, POWER($4, t.attempts))) * INTERVAL '1 second'
    WHERE id IN (
        SELECT t.id
        FROM tickets as t
        WHERE t.status = 'pending' AND t.runat <= $1::Timestamptz
        ORDER BY t.runat ASC, t.nice ASC
        LIMIT $5
        FOR UPDATE SKIP LOCKED
    )
    RETURNING id, status, runat, nice, type, ctime, mtime, attempts, payload, error_reason
),
future_ticket AS (
    SELECT ft.id, ft.status, ft.runat, ft.nice, ft.type, ft.ctime, ft.mtime, ft.attempts, ft.payload, ft.error_reason
    FROM tickets as ft
    WHERE status = 'pending'
    ORDER BY ft.runat ASC, ft.nice ASC
    LIMIT 1
    FOR SHARE SKIP LOCKED
)
SELECT
    'ticket' AS ticket,
    rescheduled_tickets.id           AS id,
    rescheduled_tickets.status       AS status,
    rescheduled_tickets.runat        AS runat,
    rescheduled_tickets.nice         AS nice,
    rescheduled_tickets.type         AS type,
    rescheduled_tickets.ctime        AS ctime,
    rescheduled_tickets.mtime        AS mtime,
    rescheduled_tickets.attempts     AS attempts,
    rescheduled_tickets.payload      AS payload,
    rescheduled_tickets.error_reason AS error_reason
FROM rescheduled_tickets
UNION ALL
SELECT
    'future_ticket'            AS ticket,
    future_ticket.id           AS id,
    future_ticket.status       AS status,
    future_ticket.runat        AS runat,
    future_ticket.nice         AS nice,
    future_ticket.type         AS type,
    future_ticket.ctime        AS ctime,
    future_ticket.mtime        AS mtime,
    future_ticket.attempts     AS attempts,
    future_ticket.payload      AS payload,
    future_ticket.error_reason AS error_reason
FROM future_ticket
WHERE NOT EXISTS (SELECT 1 FROM rescheduled_tickets)
`

type PollTicketsParams struct {
	Now         pgtype.Timestamptz
	Ttr         int32
	MaxDelay    int32
	BackoffBase float64
	Lim         int32
}

type PollTicketsRow struct {
	Ticket      string
	ID          uuid.UUID
	Status      string
	Runat       pgtype.Timestamptz
	Nice        int16
	Type        string
	Ctime       pgtype.Timestamptz
	Mtime       pgtype.Timestamptz
	Attempts    int32
	Payload     []byte
	ErrorReason []byte
}

func (q *Queries) PollTickets(ctx context.Context, arg PollTicketsParams) ([]PollTicketsRow, error) {
	rows, err := q.db.Query(ctx, pollTickets,
		arg.Now,
		arg.Ttr,
		arg.MaxDelay,
		arg.BackoffBase,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PollTicketsRow
	for rows.Next() {
		var i PollTicketsRow
		if err := rows.Scan(
			&i.Ticket,
			&i.ID,
			&i.Status,
			&i.Runat,
			&i.Nice,
			&i.Type,
			&i.Ctime,
			&i.Mtime,
			&i.Attempts,
			&i.Payload,
			&i.ErrorReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putTicket = `-- name: PutTicket :exec
INSERT INTO tickets (id, status, runat, nice, type, ctime, mtime, attempts, payload, error_reason)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (id) DO UPDATE SET
	status = EXCLUDED.status,
	runat = EXCLUDED.runat,
	nice = EXCLUDED.nice,
	type = EXCLUDED.type,
	ctime = EXCLUDED.ctime,
	mtime = EXCLUDED.mtime,
	attempts = EXCLUDED.attempts,
	payload = EXCLUDED.payload,
	error_reason = EXCLUDED.error_reason
`

type PutTicketParams struct {
	ID          uuid.UUID
	Status      string
	Runat       pgtype.Timestamptz
	Nice        int16
	Type        string
	Ctime       pgtype.Timestamptz
	Mtime       pgtype.Timestamptz
	Attempts    int32
	Payload     []byte
	ErrorReason []byte
}

func (q *Queries) PutTicket(ctx context.Context, arg PutTicketParams) error {
	_, err := q.db.Exec(ctx, putTicket,
		arg.ID,
		arg.Status,
		arg.Runat,
		arg.Nice,
		arg.Type,
		arg.Ctime,
		arg.Mtime,
		arg.Attempts,
		arg.Payload,
		arg.ErrorReason,
	)
	return err
}
